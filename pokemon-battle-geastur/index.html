<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Pokemon Battle - Hand Gesture Control</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      color: white;
    }

    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .container {
      display: flex;
      gap: 20px;
      margin-top: 20px;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 1400px;
    }

    .video-section {
      background: white;
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    }

    .video-container {
      position: relative;
      width: 640px;
      height: 480px;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
    }

    #video {
      position: absolute;
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
    }

    #canvas {
      position: absolute;
      width: 100%;
      height: 100%;
      transform: scaleX(-1);
    }

    .game-section {
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      color: #333;
      width: 500px;
    }

    #battleScene {
      width: 100%;
      height: 500px;
      background: linear-gradient(180deg, #87CEEB 0%, #98D8C8 50%, #8FBC8F 100%);
      border-radius: 10px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
      box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.2);
    }

    .hp-bars {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
      gap: 15px;
    }

    .hp-bar {
      flex: 1;
      background: #f0f0f0;
      border-radius: 10px;
      overflow: hidden;
      border: 3px solid #333;
    }

    .hp-label {
      display: flex;
      justify-content: space-between;
      padding: 5px 10px;
      background: #333;
      color: white;
      font-weight: bold;
      font-size: 0.9em;
    }

    .hp-fill {
      height: 25px;
      width: 100%;
      transition: width 0.5s ease;
    }

    .player-hp {
      background: linear-gradient(90deg, #4CAF50, #8BC34A);
    }

    .enemy-hp {
      background: linear-gradient(90deg, #F44336, #FF9800);
    }

    .hp-value {
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    }

    .battle-info {
      background: #333;
      color: white;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
      text-align: center;
      font-weight: bold;
      min-height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 40px;
      border-radius: 20px;
      text-align: center;
      z-index: 1000;
      display: none;
      animation: fadeIn 0.5s ease;
      border: 5px solid gold;
      box-shadow: 0 0 50px gold;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }

    .victory {
      color: #FFD700;
      font-size: 3em;
      margin-bottom: 20px;
    }

    .defeat {
      color: #FF6B6B;
      font-size: 3em;
      margin-bottom: 20px;
    }

    .restart-btn {
      background: linear-gradient(135deg, #4CAF50, #2E7D32);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.2em;
      border-radius: 10px;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.3s;
    }

    .restart-btn:hover {
      transform: scale(1.1);
    }

    .gesture-info {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
      border-left: 4px solid #667eea;
    }

    .gesture-info h3 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .gesture-item {
      padding: 8px 0;
      border-bottom: 1px solid #e0e0e0;
    }

    .gesture-item:last-child {
      border-bottom: none;
    }

    .pokemon-list {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 20px;
    }

    .pokemon-card {
      background: linear-gradient(135deg, #ffd89b 0%, #19547b 100%);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      color: white;
    }

    .pokemon-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .pokemon-card.selected {
      border: 4px solid #4CAF50;
      transform: scale(1.05);
    }

    .pokemon-name {
      font-size: 1.3em;
      font-weight: bold;
      margin-bottom: 5px;
    }

    .pokemon-emoji {
      font-size: 3em;
      margin: 10px 0;
    }

    .attacks {
      background: #fff3cd;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
    }

    .attacks h3 {
      color: #856404;
      margin-bottom: 10px;
    }

    .attack-btn {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      color: white;
      border: none;
      padding: 15px 25px;
      margin: 5px;
      border-radius: 8px;
      font-size: 1em;
      cursor: pointer;
      transition: transform 0.2s;
      width: calc(50% - 10px);
      display: inline-block;
    }

    .attack-btn:hover:not(:disabled) {
      transform: scale(1.1);
    }

    .attack-btn:active:not(:disabled) {
      transform: scale(0.95);
    }

    .attack-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .damage-indicator {
      position: absolute;
      color: #FF6B6B;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      animation: floatUp 1s ease forwards;
      pointer-events: none;
      z-index: 100;
    }

    @keyframes floatUp {
      0% { transform: translateY(0) scale(1); opacity: 1; }
      100% { transform: translateY(-100px) scale(0.5); opacity: 0; }
    }

    .status {
      background: #d4edda;
      color: #155724;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      border-left: 4px solid #28a745;
      font-weight: bold;
    }

    .current-gesture {
      background: #667eea;
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 1.2em;
      text-align: center;
      margin: 10px 0;
      font-weight: bold;
    }

    .instructions {
      background: #fff3e0;
      color: #e65100;
      padding: 15px;
      border-radius: 10px;
      margin-top: 15px;
      font-size: 0.9em;
      line-height: 1.6;
    }

    @media (max-width: 1024px) {
      .container {
        flex-direction: column;
      }

      .video-container {
        width: 100%;
        max-width: 640px;
      }

      .game-section {
        width: 100%;
        max-width: 640px;
      }
    }

    @media (max-width: 768px) {
      h1 {
        font-size: 1.8em;
        text-align: center;
      }

      .video-container {
        width: 100%;
        height: 400px;
      }

      #battleScene {
        height: 400px;
      }

      .pokemon-list {
        grid-template-columns: 1fr;
      }

      .attack-btn {
        width: 100%;
        margin: 5px 0;
      }

      .hp-bars {
        flex-direction: column;
        gap: 10px;
      }
    }
  </style>
</head>

<body>
  <h1>üéÆ 3D Pokemon Battle - Hand Gesture Control</h1>
  <p style="margin-bottom: 20px; font-size: 1.1em;">Control Pokemon with your hand gestures - Watch them fight in 3D!
  </p>

  <div class="container">
    <div class="video-section">
      <div class="video-container">
        <video id="video" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
      </div>
      <div class="current-gesture" id="currentGesture">Detecting gestures...</div>

      <div class="gesture-info">
        <h3>üëã Gesture Controls:</h3>
        <div class="gesture-item">‚úä <strong>Fist (Closed Hand)</strong> ‚Üí Select Pokemon</div>
        <div class="gesture-item">‚úåÔ∏è <strong>Peace Sign (2 Fingers)</strong> ‚Üí Attack 1</div>
        <div class="gesture-item">üññ <strong>Three Fingers</strong> ‚Üí Attack 2</div>
        <div class="gesture-item">‚úã <strong>Open Palm (5 Fingers)</strong> ‚Üí Attack 3</div>
        <div class="gesture-item">üëç <strong>Thumbs Up</strong> ‚Üí Special Attack</div>
      </div>
    </div>

    <div class="game-section">
      <div id="battleScene"></div>

      <!-- HP Bars -->
      <div class="hp-bars">
        <div class="hp-bar">
          <div class="hp-label">
            <span>Player HP</span>
            <span class="hp-value" id="playerHP">100</span>
          </div>
          <div class="hp-fill player-hp" id="playerHPBar" style="width: 100%"></div>
        </div>
        <div class="hp-bar">
          <div class="hp-label">
            <span>Enemy HP</span>
            <span class="hp-value" id="enemyHP">100</span>
          </div>
          <div class="hp-fill enemy-hp" id="enemyHPBar" style="width: 100%"></div>
        </div>
      </div>

      <div class="battle-info" id="battleInfo">
        Choose your Pokemon to start the battle!
      </div>

      <!-- Game Over Screen -->
      <div class="game-over" id="gameOverScreen">
        <div id="gameOverTitle"></div>
        <div id="gameOverMessage"></div>
        <button class="restart-btn" id="restartBtn">Play Again</button>
      </div>

      <h2>Choose Your Pokemon</h2>
      <div class="pokemon-list">
        <div class="pokemon-card" data-pokemon="pikachu">
          <div class="pokemon-emoji">‚ö°</div>
          <div class="pokemon-name">Pikachu</div>
          <div>HP: 100 | Attack: 20</div>
        </div>
        <div class="pokemon-card" data-pokemon="charizard">
          <div class="pokemon-emoji">üî•</div>
          <div class="pokemon-name">Charizard</div>
          <div>HP: 120 | Attack: 25</div>
        </div>
        <div class="pokemon-card" data-pokemon="blastoise">
          <div class="pokemon-emoji">üíß</div>
          <div class="pokemon-name">Blastoise</div>
          <div>HP: 110 | Attack: 22</div>
        </div>
        <div class="pokemon-card" data-pokemon="venusaur">
          <div class="pokemon-emoji">üåø</div>
          <div class="pokemon-name">Venusaur</div>
          <div>HP: 115 | Attack: 23</div>
        </div>
      </div>

      <div class="attacks">
        <h3>Available Attacks:</h3>
        <button class="attack-btn" data-attack="0">‚ö° Thunderbolt</button>
        <button class="attack-btn" data-attack="1">üî• Flamethrower</button>
        <button class="attack-btn" data-attack="2">üí´ Hyper Beam</button>
        <button class="attack-btn" data-attack="3">‚ú® Special Move</button>
      </div>

      <div class="status" id="status">
        Ready! Show a gesture to start...
      </div>

      <div class="instructions">
        <strong>üìã How to use:</strong><br>
        1. Allow camera access when prompted<br>
        2. Show your hand to the camera<br>
        3. Make gestures to select Pokemon and attack<br>
        4. Hold gesture for 1 second to activate<br>
        5. Watch the 3D battle animation!<br>
        6. First to reduce opponent's HP to 0 wins!
      </div>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const currentGestureDiv = document.getElementById('currentGesture');
    const pokemonCards = document.querySelectorAll('.pokemon-card');
    const attackBtns = document.querySelectorAll('.attack-btn');
    const playerHPDisplay = document.getElementById('playerHP');
    const enemyHPDisplay = document.getElementById('enemyHP');
    const playerHPBar = document.getElementById('playerHPBar');
    const enemyHPBar = document.getElementById('enemyHPBar');
    const battleInfo = document.getElementById('battleInfo');
    const gameOverScreen = document.getElementById('gameOverScreen');
    const gameOverTitle = document.getElementById('gameOverTitle');
    const gameOverMessage = document.getElementById('gameOverMessage');
    const restartBtn = document.getElementById('restartBtn');

    // Game state
    let selectedPokemon = null;
    let lastGesture = null;
    let gestureHoldStart = null;
    const HOLD_DURATION = 1000;
    
    // Game stats
    let playerHP = 100;
    let enemyHP = 100;
    let playerMaxHP = 100;
    let enemyMaxHP = 100;
    let playerAttack = 20;
    let isPlayerTurn = true;
    let gameActive = true;
    let attackCooldown = false;
    const ATTACK_COOLDOWN_TIME = 2000;

    // Pokemon stats
    const pokemonStats = {
      pikachu: { hp: 100, attack: 20, speed: 90 },
      charizard: { hp: 120, attack: 25, speed: 85 },
      blastoise: { hp: 110, attack: 22, speed: 80 },
      venusaur: { hp: 115, attack: 23, speed: 75 }
    };

    const pokemonAttacks = {
      pikachu: ['Thunderbolt', 'Quick Attack', 'Iron Tail', 'Thunder'],
      charizard: ['Flamethrower', 'Fire Blast', 'Air Slash', 'Dragon Rage'],
      blastoise: ['Hydro Pump', 'Water Gun', 'Skull Bash', 'Hydro Cannon'],
      venusaur: ['Solar Beam', 'Vine Whip', 'Razor Leaf', 'Frenzy Plant']
    };

    // Three.js variables
    let scene, camera3d, renderer, playerPokemon, enemyPokemon, animationId;
    const battleScene = document.getElementById('battleScene');

    function initThreeJS() {
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

      camera3d = new THREE.PerspectiveCamera(75, battleScene.clientWidth / battleScene.clientHeight, 0.1, 1000);
      camera3d.position.set(0, 3, 8);
      camera3d.lookAt(0, 1, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(battleScene.clientWidth, battleScene.clientHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      battleScene.appendChild(renderer.domElement);

      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);

      const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
      sunLight.position.set(5, 10, 5);
      sunLight.castShadow = true;
      sunLight.shadow.mapSize.width = 2048;
      sunLight.shadow.mapSize.height = 2048;
      scene.add(sunLight);

      // Ground
      const groundGeometry = new THREE.CircleGeometry(15, 32);
      const groundMaterial = new THREE.MeshStandardMaterial({
        color: 0x8FBC8F,
        roughness: 0.8,
        metalness: 0.2
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Battle platform
      const platformGeometry = new THREE.CylinderGeometry(3, 3.5, 0.3, 32);
      const platformMaterial = new THREE.MeshStandardMaterial({
        color: 0xD2691E,
        roughness: 0.7
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = 0.15;
      platform.castShadow = true;
      platform.receiveShadow = true;
      scene.add(platform);

      createEnemyPokemon();
      animate();
    }

    function updateHPBars() {
      const playerPercentage = (playerHP / playerMaxHP) * 100;
      const enemyPercentage = (enemyHP / enemyMaxHP) * 100;
      
      playerHPBar.style.width = `${playerPercentage}%`;
      enemyHPBar.style.width = `${enemyPercentage}%`;
      
      playerHPDisplay.textContent = playerHP;
      enemyHPDisplay.textContent = enemyHP;
      
      // Change color based on HP
      if (playerPercentage < 30) {
        playerHPBar.style.background = 'linear-gradient(90deg, #F44336, #FF5722)';
      } else if (playerPercentage < 60) {
        playerHPBar.style.background = 'linear-gradient(90deg, #FF9800, #FFB74D)';
      } else {
        playerHPBar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
      }
      
      if (enemyPercentage < 30) {
        enemyHPBar.style.background = 'linear-gradient(90deg, #F44336, #FF5722)';
      } else if (enemyPercentage < 60) {
        enemyHPBar.style.background = 'linear-gradient(90deg, #FF9800, #FFB74D)';
      } else {
        enemyHPBar.style.background = 'linear-gradient(90deg, #F44336, #FF9800)';
      }
    }

    function showDamageIndicator(target, damage) {
      const indicator = document.createElement('div');
      indicator.className = 'damage-indicator';
      indicator.textContent = `-${damage}`;
      indicator.style.left = '50%';
      indicator.style.top = '50%';
      
      if (target === 'player') {
        indicator.style.color = '#FF6B6B';
        indicator.style.left = '30%';
      } else {
        indicator.style.color = '#FFD700';
        indicator.style.left = '70%';
      }
      
      battleScene.appendChild(indicator);
      
      setTimeout(() => {
        indicator.remove();
      }, 1000);
    }

    function calculateDamage(attacker, defender, attackType) {
      let baseDamage = pokemonStats[attacker].attack;
      let multiplier = 1;
      
      // Type advantages
      const typeAdvantages = {
        pikachu: { blastoise: 0.5, venusaur: 2.0 },
        charizard: { venusaur: 2.0, blastoise: 0.5 },
        blastoise: { charizard: 2.0, pikachu: 0.5 },
        venusaur: { blastoise: 2.0, charizard: 0.5 }
      };
      
      if (typeAdvantages[attacker] && typeAdvantages[attacker][defender]) {
        multiplier = typeAdvantages[attacker][defender];
      }
      
      // Attack type multiplier
      const attackMultipliers = [1.0, 1.2, 1.5, 2.0]; // Regular, Strong, Hyper, Special
      multiplier *= attackMultipliers[attackType];
      
      // Critical hit chance
      const criticalChance = 0.1;
      if (Math.random() < criticalChance) {
        multiplier *= 1.5;
        battleInfo.textContent = "Critical Hit!";
      }
      
      // Random variance
      const variance = 0.8 + Math.random() * 0.4;
      
      const damage = Math.floor(baseDamage * multiplier * variance);
      
      return Math.max(1, damage);
    }

    function enemyAttack() {
      if (!gameActive || !selectedPokemon) return;
      
      const enemyPokemonType = enemyPokemon.userData.type;
      const attackType = Math.floor(Math.random() * 4);
      
      setTimeout(() => {
        const damage = calculateDamage(enemyPokemonType, selectedPokemon, attackType);
        playerHP = Math.max(0, playerHP - damage);
        updateHPBars();
        showDamageIndicator('player', damage);
        
        createAttackEffect(attackType, false);
        animateAttack(attackType, false);
        
        battleInfo.textContent = `Enemy ${enemyPokemonType} used ${pokemonAttacks[enemyPokemonType][attackType]}!`;
        
        if (playerHP <= 0) {
          gameOver(false);
        } else {
          isPlayerTurn = true;
          enableAttacks();
        }
      }, 1500);
    }

    function gameOver(playerWon) {
      gameActive = false;
      
      if (playerWon) {
        gameOverTitle.innerHTML = '<div class="victory">üéâ VICTORY!</div>';
        gameOverMessage.textContent = `Your ${selectedPokemon} defeated the enemy!`;
        
        // Victory animation
        if (playerPokemon) {
          playerPokemon.userData.victory = true;
          const originalScale = playerPokemon.scale.clone();
          playerPokemon.scale.set(originalScale.x * 1.3, originalScale.y * 1.3, originalScale.z * 1.3);
          
          // Add victory particles
          createVictoryParticles();
        }
      } else {
        gameOverTitle.innerHTML = '<div class="defeat">üíî DEFEAT!</div>';
        gameOverMessage.textContent = `Your ${selectedPokemon} was defeated...`;
        
        // Defeat animation
        if (playerPokemon) {
          playerPokemon.userData.defeated = true;
          playerPokemon.position.y = 0.5;
          playerPokemon.rotation.x = Math.PI / 2;
        }
      }
      
      gameOverScreen.style.display = 'block';
      disableAttacks();
    }

    function createVictoryParticles() {
      for (let i = 0; i < 50; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: Math.random() * 0xFFFFFF,
          transparent: true,
          opacity: 0.8
        });
        const particle = new THREE.Mesh(geometry, material);
        
        particle.position.set(
          (Math.random() - 0.5) * 10,
          Math.random() * 5,
          (Math.random() - 0.5) * 10
        );
        
        particle.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.1,
          Math.random() * 0.2,
          (Math.random() - 0.5) * 0.1
        );
        
        scene.add(particle);
        
        setTimeout(() => {
          scene.remove(particle);
        }, 2000);
      }
    }

    function restartGame() {
      gameOverScreen.style.display = 'none';
      gameActive = true;
      isPlayerTurn = true;
      attackCooldown = false;
      
      // Reset HP
      playerHP = playerMaxHP;
      enemyHP = enemyMaxHP;
      updateHPBars();
      
      // Reset Pokemon positions
      if (playerPokemon) {
        playerPokemon.position.set(0, 1, 2);
        playerPokemon.rotation.set(0, 0, 0);
        playerPokemon.scale.setScalar(1);
        playerPokemon.userData.victory = false;
        playerPokemon.userData.defeated = false;
      }
      
      // Create new enemy
      createEnemyPokemon();
      
      battleInfo.textContent = "Game restarted! Choose a Pokemon!";
      statusDiv.textContent = "Ready! Show a gesture to start...";
      enableAttacks();
    }

    function disableAttacks() {
      attackBtns.forEach(btn => {
        btn.disabled = true;
      });
    }

    function enableAttacks() {
      attackBtns.forEach(btn => {
        btn.disabled = !isPlayerTurn || !gameActive;
      });
    }

    function createPokemon3D(type, isPlayer = true) {
      const group = new THREE.Group();
      group.userData.type = type;

      const colors = {
        pikachu: { body: 0xFFD700, detail: 0xFF6B6B },
        charizard: { body: 0xFF6347, detail: 0xFFA500 },
        blastoise: { body: 0x4682B4, detail: 0x1E90FF },
        venusaur: { body: 0x32CD32, detail: 0x228B22 }
      };

      const color = colors[type] || colors.pikachu;

      // Body
      const bodyGeometry = new THREE.SphereGeometry(0.8, 32, 32);
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: color.body,
        roughness: 0.4,
        metalness: 0.1
      });
      const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
      body.castShadow = true;
      body.scale.set(1, 1.2, 1);
      group.add(body);

      // Head
      const headGeometry = new THREE.SphereGeometry(0.6, 32, 32);
      const head = new THREE.Mesh(headGeometry, bodyMaterial);
      head.position.y = 1.3;
      head.castShadow = true;
      group.add(head);

      // Eyes
      const eyeGeometry = new THREE.SphereGeometry(0.12, 16, 16);
      const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      leftEye.position.set(-0.2, 1.4, 0.5);
      group.add(leftEye);

      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      rightEye.position.set(0.2, 1.4, 0.5);
      group.add(rightEye);

      // Pokemon-specific features
      if (type === 'pikachu') {
        // Ears
        const earGeometry = new THREE.ConeGeometry(0.15, 0.6, 8);
        const earMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700 });

        const leftEar = new THREE.Mesh(earGeometry, earMaterial);
        leftEar.position.set(-0.4, 1.8, 0);
        leftEar.rotation.z = -0.3;
        leftEar.castShadow = true;
        group.add(leftEar);

        const rightEar = new THREE.Mesh(earGeometry, earMaterial);
        rightEar.position.set(0.4, 1.8, 0);
        rightEar.rotation.z = 0.3;
        rightEar.castShadow = true;
        group.add(rightEar);

        // Cheeks
        const cheekGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const cheekMaterial = new THREE.MeshStandardMaterial({ color: 0xFF0000 });

        const leftCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
        leftCheek.position.set(-0.5, 1.3, 0.3);
        group.add(leftCheek);

        const rightCheek = new THREE.Mesh(cheekGeometry, cheekMaterial);
        rightCheek.position.set(0.5, 1.3, 0.3);
        group.add(rightCheek);
      } else if (type === 'charizard') {
        // Wings
        const wingGeometry = new THREE.PlaneGeometry(0.6, 1.2);
        const wingMaterial = new THREE.MeshStandardMaterial({
          color: 0xFFA500,
          side: THREE.DoubleSide
        });

        const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
        leftWing.position.set(-0.9, 0.8, -0.3);
        leftWing.rotation.z = Math.PI / 2;
        leftWing.rotation.y = -0.5;
        leftWing.castShadow = true;
        group.add(leftWing);

        const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
        rightWing.position.set(0.9, 0.8, -0.3);
        rightWing.rotation.z = -Math.PI / 2;
        rightWing.rotation.y = 0.5;
        rightWing.castShadow = true;
        group.add(rightWing);
      }

      // Arms
      const armGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.8, 16);
      const armMaterial = new THREE.MeshStandardMaterial({ color: color.body });

      const leftArm = new THREE.Mesh(armGeometry, armMaterial);
      leftArm.position.set(-0.8, 0.3, 0.2);
      leftArm.rotation.z = 0.5;
      leftArm.castShadow = true;
      group.add(leftArm);

      const rightArm = new THREE.Mesh(armGeometry, armMaterial);
      rightArm.position.set(0.8, 0.3, 0.2);
      rightArm.rotation.z = -0.5;
      rightArm.castShadow = true;
      group.add(rightArm);

      // Legs
      const legGeometry = new THREE.CylinderGeometry(0.18, 0.15, 0.6, 16);

      const leftLeg = new THREE.Mesh(legGeometry, armMaterial);
      leftLeg.position.set(-0.4, -0.9, 0);
      leftLeg.castShadow = true;
      group.add(leftLeg);

      const rightLeg = new THREE.Mesh(legGeometry, armMaterial);
      rightLeg.position.set(0.4, -0.9, 0);
      rightLeg.castShadow = true;
      group.add(rightLeg);

      return group;
    }

    function createEnemyPokemon() {
      const enemyTypes = ['pikachu', 'charizard', 'blastoise', 'venusaur'];
      const randomType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
      
      if (enemyPokemon) {
        scene.remove(enemyPokemon);
      }
      
      enemyPokemon = createPokemon3D(randomType, false);
      enemyPokemon.position.set(0, 1, -4);
      enemyPokemon.rotation.y = Math.PI;
      scene.add(enemyPokemon);
      
      enemyPokemon.userData.idleOffset = Math.random() * Math.PI * 2;
      
      // Set enemy stats
      enemyMaxHP = pokemonStats[randomType].hp;
      enemyHP = enemyMaxHP;
      updateHPBars();
    }

    function updatePlayerPokemon(type) {
      if (playerPokemon) {
        scene.remove(playerPokemon);
      }
      
      playerPokemon = createPokemon3D(type, true);
      playerPokemon.position.set(0, 1, 2);
      scene.add(playerPokemon);
      
      playerPokemon.userData.idleOffset = Math.random() * Math.PI * 2;
      
      // Set player stats
      playerMaxHP = pokemonStats[type].hp;
      playerHP = playerMaxHP;
      playerAttack = pokemonStats[type].attack;
      updateHPBars();
    }

    function createAttackEffect(attackType, fromPlayer = true) {
      const startPos = fromPlayer ?
        playerPokemon.position.clone() :
        enemyPokemon.position.clone();
      const endPos = fromPlayer ?
        enemyPokemon.position.clone() :
        playerPokemon.position.clone();

      startPos.y += 1;
      endPos.y += 1;

      let projectile;

      if (attackType === 0) {
        // Thunderbolt
        const geometry = new THREE.SphereGeometry(0.3, 16, 16);
        const material = new THREE.MeshBasicMaterial({
          color: 0xFFFF00,
          transparent: true,
          opacity: 0.9
        });
        projectile = new THREE.Mesh(geometry, material);
      } else if (attackType === 1) {
        // Flamethrower
        const geometry = new THREE.SphereGeometry(0.4, 16, 16);
        const material = new THREE.MeshBasicMaterial({
          color: 0xFF4500,
          transparent: true,
          opacity: 0.8
        });
        projectile = new THREE.Mesh(geometry, material);
      } else if (attackType === 2) {
        // Hyper Beam
        const geometry = new THREE.CylinderGeometry(0.2, 0.2, 2, 16);
        const material = new THREE.MeshBasicMaterial({
          color: 0xFF00FF,
          transparent: true,
          opacity: 0.8
        });
        projectile = new THREE.Mesh(geometry, material);
        projectile.rotation.z = Math.PI / 2;
      } else {
        // Special Move
        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
        const material = new THREE.MeshBasicMaterial({
          color: 0x00FFFF,
          transparent: true,
          opacity: 0.9
        });
        projectile = new THREE.Mesh(geometry, material);
      }

      projectile.position.copy(startPos);
      scene.add(projectile);

      const duration = 800;
      const startTime = Date.now();

      function animateProjectile() {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);

        projectile.position.lerpVectors(startPos, endPos, progress);
        projectile.rotation.y += 0.2;

        if (progress < 1) {
          requestAnimationFrame(animateProjectile);
        } else {
          createImpactEffect(endPos, attackType);
          scene.remove(projectile);
          
          const target = fromPlayer ? enemyPokemon : playerPokemon;
          shakeObject(target);
        }
      }

      animateProjectile();
    }

    function createImpactEffect(position, attackType) {
      const colors = [0xFFFF00, 0xFF4500, 0xFF00FF, 0x00FFFF];
      const color = colors[attackType] || 0xFFFFFF;

      for (let i = 0; i < 15; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 8, 8);
        const material = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.8
        });
        const particle = new THREE.Mesh(geometry, material);
        particle.position.copy(position);
        
        const velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2,
          (Math.random() - 0.5) * 0.2
        );
        
        scene.add(particle);
        
        const startTime = Date.now();
        function animateParticle() {
          const elapsed = Date.now() - startTime;
          if (elapsed > 500) {
            scene.remove(particle);
            return;
          }
          
          particle.position.add(velocity);
          particle.scale.multiplyScalar(0.98);
          requestAnimationFrame(animateParticle);
        }
        
        animateParticle();
      }
    }

    function shakeObject(object) {
      const originalPosition = object.position.clone();
      const shakeDuration = 500;
      const startTime = Date.now();
      
      function animateShake() {
        const elapsed = Date.now() - startTime;
        if (elapsed > shakeDuration) {
          object.position.copy(originalPosition);
          return;
        }
        
        const intensity = 0.1 * (1 - elapsed / shakeDuration);
        object.position.x = originalPosition.x + (Math.random() - 0.5) * intensity;
        object.position.y = originalPosition.y + (Math.random() - 0.5) * intensity;
        
        requestAnimationFrame(animateShake);
      }
      
      animateShake();
    }

    function executeAttack(attackType) {
      if (!selectedPokemon || !gameActive || !isPlayerTurn || attackCooldown) return;

      attackCooldown = true;
      isPlayerTurn = false;
      disableAttacks();

      const damage = calculateDamage(selectedPokemon, enemyPokemon.userData.type, parseInt(attackType));
      enemyHP = Math.max(0, enemyHP - damage);
      updateHPBars();
      showDamageIndicator('enemy', damage);

      createAttackEffect(parseInt(attackType), true);
      animateAttack(parseInt(attackType), true);

      battleInfo.textContent = `${selectedPokemon.toUpperCase()} uses ${pokemonAttacks[selectedPokemon][attackType]}!`;
      statusDiv.textContent = `Dealt ${damage} damage!`;

      if (enemyHP <= 0) {
        setTimeout(() => gameOver(true), 1500);
      } else {
        setTimeout(() => {
          battleInfo.textContent = "Enemy's turn!";
          enemyAttack();
        }, 1000);
      }

      setTimeout(() => {
        attackCooldown = false;
      }, ATTACK_COOLDOWN_TIME);
    }

    function animateAttack(attackType, isPlayer) {
      const target = isPlayer ? playerPokemon : enemyPokemon;
      if (!target) return;

      const startTime = Date.now();
      const duration = 1000;

      function animate() {
        const elapsed = Date.now() - startTime;
        if (elapsed > duration) {
          target.position.y = isPlayer ? 1 : 1;
          return;
        }

        const progress = elapsed / duration;
        const bounce = Math.sin(progress * Math.PI * 2) * 0.2;
        target.position.y = (isPlayer ? 1 : 1) + bounce;

        requestAnimationFrame(animate);
      }

      animate();
    }

    function detectGesture(handLandmarks) {
      const tips = [4, 8, 12, 16, 20];
      const fingerBases = [2, 5, 9, 13, 17];
      let extendedFingers = 0;

      for (let i = 0; i < tips.length; i++) {
        const tip = handLandmarks[tips[i]];
        const base = handLandmarks[fingerBases[i]];
        
        if (i === 0) {
          if (tip.x < base.x) extendedFingers++;
        } else {
          if (tip.y < base.y) extendedFingers++;
        }
      }

      let gesture = "";
      switch (extendedFingers) {
        case 0: gesture = "‚úä Fist (Closed Hand)"; break;
        case 1: gesture = "üëç Thumbs Up"; break;
        case 2: gesture = "‚úåÔ∏è Peace Sign"; break;
        case 3: gesture = "üññ Three Fingers"; break;
        case 4: gesture = "ü§è Four Fingers"; break;
        case 5: gesture = "‚úã Open Palm"; break;
        default: gesture = "Unknown Gesture";
      }

      return {
        gesture: gesture,
        count: extendedFingers,
        name: ["fist", "thumb", "peace", "three", "four", "palm"][extendedFingers] || "unknown"
      };
    }

    function handleGesture(newGesture) {
      currentGestureDiv.textContent = `Current Gesture: ${newGesture.gesture}`;
      
      if (newGesture.name !== lastGesture?.name) {
        gestureHoldStart = Date.now();
        lastGesture = newGesture;
        return;
      }

      const holdTime = Date.now() - gestureHoldStart;
      if (holdTime < HOLD_DURATION) {
        const timeLeft = Math.ceil((HOLD_DURATION - holdTime) / 100);
        statusDiv.textContent = `Hold for ${timeLeft/10}s...`;
        return;
      }

      if (!gameActive) return;

      switch (newGesture.name) {
        case "fist":
          if (!selectedPokemon) {
            const randomPokemon = ["pikachu", "charizard", "blastoise", "venusaur"][Math.floor(Math.random() * 4)];
            selectPokemon(randomPokemon);
          }
          break;
        case "thumb":
          executeAttack('3');
          break;
        case "peace":
          executeAttack('0');
          break;
        case "three":
          executeAttack('1');
          break;
        case "four":
          executeAttack('2');
          break;
        case "palm":
          executeAttack('3');
          break;
      }

      statusDiv.textContent = `Gesture detected: ${newGesture.gesture}`;
      gestureHoldStart = Date.now();
    }

    function selectPokemon(pokemonName) {
      selectedPokemon = pokemonName;
      
      pokemonCards.forEach(card => {
        card.classList.remove('selected');
        if (card.dataset.pokemon === pokemonName) {
          card.classList.add('selected');
        }
      });

      updatePlayerPokemon(pokemonName);
      
      battleInfo.textContent = `Selected: ${pokemonName.toUpperCase()}! Battle Start!`;
      statusDiv.textContent = `Your ${pokemonName} is ready! Use gestures to attack!`;
      
      enableAttacks();
    }

    function animate() {
      animationId = requestAnimationFrame(animate);

      // Animate player Pokemon
      if (playerPokemon && !playerPokemon.userData.defeated) {
        const time = Date.now() * 0.001;
        if (!playerPokemon.userData.victory) {
          playerPokemon.position.y = 1 + Math.sin(time + playerPokemon.userData.idleOffset) * 0.1;
          playerPokemon.rotation.y = Math.sin(time * 0.5) * 0.1;
        } else {
          // Victory animation
          playerPokemon.rotation.y += 0.02;
        }
      }

      // Animate enemy Pokemon
      if (enemyPokemon) {
        const time = Date.now() * 0.001;
        enemyPokemon.position.y = 1 + Math.cos(time + enemyPokemon.userData.idleOffset) * 0.1;
        enemyPokemon.rotation.y = Math.PI + Math.sin(time * 0.3) * 0.1;
      }

      renderer.render(scene, camera3d);
    }

    function onResults(results) {
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        for (const landmarks of results.multiHandLandmarks) {
          drawConnectors(ctx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 2 });
          drawLandmarks(ctx, landmarks, { color: '#FF0000', lineWidth: 1 });

          const gesture = detectGesture(landmarks);
          handleGesture(gesture);
        }
      }

      ctx.restore();
    }

    // Initialize MediaPipe Hands
    const hands = new Hands({
      locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
      }
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // Initialize camera
    const camera = new Camera(video, {
      onFrame: async () => {
        await hands.send({ image: video });
      },
      width: 640,
      height: 480
    });

    camera.start();

    // Event Listeners
    pokemonCards.forEach(card => {
      card.addEventListener('click', () => {
        if (!gameActive) return;
        selectPokemon(card.dataset.pokemon);
      });
    });

    attackBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        if (isPlayerTurn && gameActive) {
          executeAttack(btn.dataset.attack);
        }
      });
    });

    restartBtn.addEventListener('click', restartGame);

    // Handle window resize
    window.addEventListener('resize', () => {
      if (renderer && camera3d && battleScene) {
        camera3d.aspect = battleScene.clientWidth / battleScene.clientHeight;
        camera3d.updateProjectionMatrix();
        renderer.setSize(battleScene.clientWidth, battleScene.clientHeight);
      }
    });

    // Initialize 3D scene
    setTimeout(() => {
      initThreeJS();
      battleInfo.textContent = "Choose your Pokemon to start the battle!";
      statusDiv.textContent = "Ready! Show your hand to the camera and make gestures.";
      disableAttacks();
    }, 100);

    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      if (camera) {
        camera.stop();
      }
    });

    // Keyboard shortcuts for testing
    document.addEventListener('keydown', (e) => {
      if (!gameActive) return;
      
      switch(e.key) {
        case '1': selectPokemon('raichu'); break;
        case '2': selectPokemon('charizard'); break;
        case '3': selectPokemon('blastoise'); break;
        case '4': selectPokemon('venusaur'); break;
        case 'q': if (isPlayerTurn) executeAttack('0'); break;
        case 'w': if (isPlayerTurn) executeAttack('1'); break;
        case 'e': if (isPlayerTurn) executeAttack('2'); break;
        case 'r': if (isPlayerTurn) executeAttack('3'); break;
        case ' ': restartGame(); break;
      }
    });
  </script>
</body>
</html>